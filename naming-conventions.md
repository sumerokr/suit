# SUIT CSS соглашения о наименовании

SUIT CSS полагается на _структурированные имена классов_ и _смысловые дефисы_
(т.е. дефисы используются не для того, чтобы просто разделять слова). Это
помогает действовать в пределах ограничений применения CSS стилей к DOM-у
(т.е. проблем с изоляцией стилей), и позволяет лучше наладить взаимодействие
между классами.

Основное архитектурное разделение выстраивается между
**[утилитами](utilities.md)** и **[компонентами](components.md)**.

**Содержание**

* [u-utilityName](#u-utilityName)
* [ComponentName](#ComponentName)
* [ComponentName--modifierName](#ComponentName--modifierName)
* [ComponentName-descendantName](#ComponentName-descendantName)
* [ComponentName.is-stateOfComponent](#is-stateOfComponent)

## [Утилиты](utilities.md)

Низкоуровневые структурные и позиционные стили. Утилиты могут применяться
напрямую к любому элементу, в том числе внутри компонента.

Синтаксис: `u-[sm|md|lg-]<utilityName>`

<a name="u-utilityName"></a>
### u-utilityName

Утилиты должны использовать имена в стиле camel case. Это отражено в примере,
демонстрирующем, как различные утилиты могут быть использованы для создания
простой структуры внутри компонента.

```html
<div class="u-cf">
    <a class="u-floatLeft" href="{{url}}">
        <img class="u-block" src="{{src}}" alt="">
    </a>
    <p class="u-sizeFill u-textBreak">
        …
    </p>
</div>
```

### Отзывчивые утилиты

Определенные утилиты имеют отзывчивые варианты используя шаблон написания:
`u-sm-<name>`, `u-md-<name>`, и `u-lg-<name>` для малых, средних и больших точек
разделения медиа-выражений.


## [Компоненты](components.md)

CSS достаточно гибкие для компонентно-специфичного стилизования.

Синтаксис: `[<namespace>-]<ComponentName>[--modifierName|-descendentName]`

Такой подход имеет несколько преимуществ для чтения и написания HTML и CSS:

* Помогает различать классы для корневого элемента компонента, его потомков
и модификаторов.
* Позволяет поддерживать низкую специфику селекторов.
* Помогает отделять семантику представления от семантики документа.

### Пространство имен (опционально)

Если есть необходимость, компоненту может быть добавлено пространство имен
в виде префикса. Например, вам захочется избежать потенциального конфликта между
стилями сторонних библиотек и собственных компонентов путем добавления префиксов
с пространствами имен.

```css
.twt-Button { /* … */ }
.twt-Tabs { /* … */ }
```

При чтении подобных классов, становится понятно, какой компонент является
частью вашей библиотеки.

<a name="ComponentName"></a>
### ComponentName

Имя компонента должно быть написано в стиле pascal case. Ничто другое в HTML
и CSS не должно быть написано в стиле pascal case.

```css
.MyComponent { /* … */ }
```

```html
<article class="MyComponent">
    …
</article>
```

<a name="ComponentName--modifierName"></a>
### ComponentName--modifierName

Для обозначения модификатора компонента используется класс, меняющий, некоторым
образом, представление базового компонента (т.е. для определенных конфигураций
компонента). Имя модификатора должно быть написано в стиле camel case
и быть отделенно от имени компонента двумя дефисами. Класс должен быть
добавлен в HTML путем _дополнения_ к основному классу компонента.

```css
/* Core button */
.Button { /* … */ }
/* Default button style */
.Button--default { /* … */ }
```

```html
<button class="Button Button--default" type="button">…</button>
```

<a name="ComponentName-descendentName"></a>
### ComponentName-descendentName

Для обозначения потомка компонента используется класс, добавляемый к дочерним
HTML элементам компонента. Это позволяет напрямую стилизовать потомков
принадлежащих конкретному компоненту. Имена потомков должны быть написаны
в стиле camel case.

```html
<article class="Tweet">
    <header class="Tweet-header">
    <img class="Tweet-avatar" src="{{src}}" alt="{{alt}}">
        …
    </header>
    <div class="Tweet-bodyText">
        …
    </div>
</article>
```

<a name="is-stateOfComponent"></a>
### ComponentName.is-stateOfComponent

Используйте `is-stateName` чтобы отразить состояние компонента. Имя состояния
должно быть написано в стиле camel case. **Никогда не применяйте стили напрямую
к этим классам; Они всегда должны быть использованы путем добавления к основным
классам.

Это означает, что состояния с одинаковыми именами могут быть использованы в
различном контексте, но каждый компонент определяет свои собственные стили для
этих состояний (соблюдая ограниченную видимость в пределах компонента).

```css
.Tweet { /* … */ }
.Tweet.is-expanded { /* … */ }
```

```html
<article class="Tweet is-expanded">
    …
</article>
```
